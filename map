import math
import networkx as nx
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap

villes = {
    "Paris": (48.8566, 2.3522),
    "Marseille": (43.2965, 5.3698),
    "Lyon": (45.764, 4.8357),
    "Toulouse": (43.6047, 1.4442),
    "Nice": (43.7102, 7.262),
    "Nantes": (47.2184, -1.5536),
    "Strasbourg": (48.5734, 7.7521),
    "Montpellier": (43.6119, 3.8772),
    "Bordeaux": (44.8378, -0.5792),
    "Lille": (50.6292, 3.0573),
    "Rennes": (48.1173, -1.6778),
    "Reims": (49.2583, 4.0317),
    "Le Havre": (49.4944, 0.1079),
    "Saint-Étienne": (45.4397, 4.3872),
    "Toulon": (43.1242, 5.928),
    "Grenoble": (45.1885, 5.7245),
    "Dijon": (47.322, 5.0415),
    "Angers": (47.4784, -0.5632),
    "Nîmes": (43.8367, 4.3601),
    "Clermont-Ferrand": (45.7772, 3.087),
}

def haversine(coord1, coord2):
    R = 6371
    lat1, lon1 = map(math.radians, coord1)
    lat2, lon2 = map(math.radians, coord2)
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat/2)**2 + math.cos(lat1)*math.cos(lat2)*math.sin(dlon/2)**2
    return 2 * R * math.asin(math.sqrt(a))

G = nx.Graph()
for ville, (lat, lon) in villes.items():
    G.add_node(ville, pos=(lon, lat))
for v1, (lat1, lon1) in villes.items():
    for v2, (lat2, lon2) in villes.items():
        if v1 != v2:
            dist = haversine((lat1, lon1), (lat2, lon2))
            G.add_edge(v1, v2, weight=dist)

mst_G = nx.minimum_spanning_tree(G)

odd_nodes = [n for n, d in mst_G.degree() if d % 2 == 1]

odd_subgraph = nx.Graph()
for i, u in enumerate(odd_nodes):
    for j, v in enumerate(odd_nodes):
        if u != v:
            odd_subgraph.add_edge(u, v, weight=G[u][v]['weight'])
matching = nx.algorithms.matching.min_weight_matching(odd_subgraph, weight='weight')
matching_edges = list(matching)

eulerian_G = nx.MultiGraph()
eulerian_G.add_nodes_from(mst_G.nodes())
eulerian_G.add_edges_from(mst_G.edges())
for u, v in matching_edges:
    eulerian_G.add_edge(u, v, weight=G[u][v]['weight'])

eulerian_circuit = list(nx.eulerian_circuit(eulerian_G))

visited = set()
tsp_path = []
for u, v in eulerian_circuit:
    if u not in visited:
        tsp_path.append(u)
        visited.add(u)
    if v not in visited:
        tsp_path.append(v)
        visited.add(v)
tsp_path.append(tsp_path[0])

fig, ax = plt.subplots(figsize=(10, 10))
m = Basemap(projection='merc',
            llcrnrlat=41.0, urcrnrlat=51.5,
            llcrnrlon=-5.5, urcrnrlon=9.5,
            resolution='i', ax=ax)
pos = {v: m(lon, lat) for v, (lat, lon) in villes.items()}

step = 0
steps = 6  # on ajoute l'étape eulérien

def draw_step():
    ax.clear()
    m.drawcoastlines()
    m.drawcountries()
    m.drawmapboundary(fill_color='lightblue')
    m.fillcontinents(color='beige', lake_color='lightblue')
    
    title = ""
    edges_to_draw = []
    odd_to_draw = []
    matching_to_draw = []
    eulerian_to_draw = []
    tsp_edges = []
    
    if step == 0:
        edges_to_draw = G.edges()
        title = "Graphe complet"
    elif step == 1:
        edges_to_draw = mst_G.edges()
        title = "MST"
    elif step == 2:
        edges_to_draw = mst_G.edges()
        odd_to_draw = odd_nodes
        title = "MST + sommets impairs"
    elif step == 3:
        edges_to_draw = mst_G.edges()
        odd_to_draw = odd_nodes
        matching_to_draw = matching_edges
        title = "MST + sommets impairs + matching minimal"
    elif step == 4:
        # Graphe eulérien : MST + matching
        eulerian_to_draw = list(eulerian_G.edges())
        title = "Graphe eulérien complet (MST + matching)"
    elif step == 5:
        tsp_edges = [(tsp_path[i], tsp_path[i+1]) for i in range(len(tsp_path)-1)]
        title = "Circuit final approximatif (Christofides)"
    
    # Tracer les arêtes
    for u, v in edges_to_draw:
        x1, y1 = pos[u]
        x2, y2 = pos[v]
        ax.plot([x1, x2], [y1, y2], color='gray', linewidth=0.7, alpha=0.7)
    for u, v in matching_to_draw:
        x1, y1 = pos[u]
        x2, y2 = pos[v]
        ax.plot([x1, x2], [y1, y2], color='blue', linewidth=1.5, alpha=0.8)
    for u, v in eulerian_to_draw:
        x1, y1 = pos[u]
        x2, y2 = pos[v]
        ax.plot([x1, x2], [y1, y2], color='purple', linewidth=1.2, alpha=0.8)
    for u, v in tsp_edges:
        x1, y1 = pos[u]
        x2, y2 = pos[v]
        ax.plot([x1, x2], [y1, y2], color='green', linewidth=2, alpha=0.8)
    
    # Tracer les sommets
    for ville, (x, y) in pos.items():
        if ville in odd_to_draw:
            ax.plot(x, y, 'ro', markersize=10)
        else:
            ax.plot(x, y, 'ro', markersize=5)
        ax.text(x + 10000, y + 10000, ville, fontsize=8)
    
    ax.set_title(f"{title} (→/← pour naviguer)", fontsize=12)

def on_key(event):
    global step
    if event.key == 'right':
        step = (step + 1) % steps
        draw_step()
        plt.draw()
    elif event.key == 'left':
        step = (step - 1) % steps
        draw_step()
        plt.draw()

draw_step()
fig.canvas.mpl_connect('key_press_event', on_key)
plt.show()
